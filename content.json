{"meta":{"title":"WOW!","subtitle":"","description":"","author":"John Doe","url":"https://yuzi2233.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"# 英语单词","date":"2023-02-16T05:02:43.617Z","updated":"2023-02-16T09:02:53.148Z","comments":true,"path":"2023/02/16/# 英语单词/","link":"","permalink":"https://yuzi2233.github.io/2023/02/16/#%20%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/","excerpt":"","text":"英语单词 externalized dissertation cumulative","categories":[],"tags":[]},{"title":"","slug":"优云域名","date":"2023-01-22T14:57:20.018Z","updated":"2023-01-22T14:57:20.018Z","comments":true,"path":"2023/01/22/优云域名/","link":"","permalink":"https://yuzi2233.github.io/2023/01/22/%E4%BC%98%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"优云域名日常工单24小时内回复。AFF和退款工单48小时内回复。微信支付请用摄像头扫码，如将二维码保存到相册支付会失败。 请务必保存下方备用网址，以防失联 地址一（新域名）：https://youyun0.net 地址二（新域名）：https://youyun9.net 地址三（新域名）：https://youyun520.com 地址四（新域名）：https://youyun520.net 地址五： https://youyun100.com 地址六： https://youyun100.net 地址七： https://youyun521.com 地址八： https://youyun521.net 地址九：https://youyun00.com （被墙） 地址十：https://youyun998.net 地址十一：https://youyun88.com （被墙） 地址十二：https://youyun88.net 地址十三：https://youyun998.com 地址十四：https://youyun999.vip 地址十五：https://youyun1.com 地址十六：https://youyun555.com 地址十七：https://youyun55.com （被墙） 地址十八：https://youyun1.net 地址十九：https://youyun0.com 地址二十：https://youyun9.com （被墙）","categories":[],"tags":[]},{"title":"","slug":"算法","date":"2023-01-16T16:15:37.142Z","updated":"2023-02-16T09:02:45.798Z","comments":true,"path":"2023/01/17/算法/","link":"","permalink":"https://yuzi2233.github.io/2023/01/17/%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法二分模板123456789101112131415161718//注意r=mid时候 mid=l+r&gt;&gt;1int l=0,r=n-1;while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(A[mid]&gt;=x) r=mid; else l=mid+1;&#125;//注意l=mid时候 mid=l+r+1&gt;&gt;1l=0,r=n-1;while(l&lt;r)&#123; int mid =l+r+1&gt;&gt;1; if(A[mid]&lt;=x) l=mid; else r=mid-1;&#125; 静态链表STLvector123456789#Include&lt;iostream&gt;#include&lt;vector&gt;//初始化vector&lt;int&gt; a(10,3) //10个，为3vector a[10] //10个vectora.size()a.empty() pair12345//二元组pair&lt;int,string&gt; i;i.first;i.secondi=&#123;10,&quot;123&quot;&#125;; string12345string s= &quot;gy&quot;;s+=&quot;gasf&quot;;s.substr(1,2) //从1开始输出两个printf(&quot;%s\\n&quot;,s.c_str()) //普通printf不能输出 动态规划思路1、状态表示 2、状态计算 背包问题 i表示物品件数，j表示空间容量 01背包问题状态表示： 1f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 属性：max 基础代码： 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int f[N][N];int v[N], w[N];int n, m;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl;&#125; 优化 思路：数组降维,由于每次只用到f[i-1][j-1],其他元素并没有用到，所以不需要二维数组，可以直接删到一维，如下所示 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int f[N];int v[N], w[N];int n, m;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125;&#125; cout &lt;&lt; f[m] &lt;&lt; endl;&#125; 但是发现结果是错误的 这是因为上述代码认为 f[j - v[i]] + w[i] 与f[i-1][j-v[i]]+w[i]等价，但实际上f[j - v[i]] + w[i]为f[i][j-v[i]+w[i]; 一维数组处理可以认为一直每一轮更新这个数组，想要得到f[i-1][j-1]，可以从后往前扫描，循环部分如下所示 12345for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125;&#125; 完全背包问题状态转移 代码 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N =1010;int n,m;int ff[N][N];int v[N],w[N],c[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;c[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; for(int x=0;x&lt;=c[i];x++) &#123; if(v[i]*x&gt;j) break; //此处为max(ff[i][j],...)的原因 // 1、ff[i-1][j]在x=0的时候等同于ff[i][j] // 2、ff[i][j]每次要和同层的比，比如第一次x=0时候算完，下一次x=1时要和上次x=0比，不是和ff[i-1][j]比了 ff[i][j] = max(ff[i][j], ff[i - 1][j - v[i] * x] + w[i] * x); &#125; &#125; &#125; printf(&quot;%d&quot;,ff[n][m]);&#125; 多重背包问题的优化（二进制+01背包 ） [j]:","categories":[],"tags":[]},{"title":"","slug":"李宏毅_深度学习","date":"2023-01-14T09:19:45.868Z","updated":"2023-02-08T15:29:54.595Z","comments":true,"path":"2023/01/14/李宏毅_深度学习/","link":"","permalink":"https://yuzi2233.github.io/2023/01/14/%E6%9D%8E%E5%AE%8F%E6%AF%85_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"李宏毅_深度学习 课程链接[李宏毅2020机器学习深度学习(完整版)国语_哔哩哔哩_bilibili] 介绍 Explainable AI:可解释性，eg：我（模型）为什么会认为这是只猫 Adversarial Attack：攻击模型 Network Compression:模型压缩 Unsupervised Learning:无监督学习 Anomaly Detection: eg：我（模型）不认识这个图像，但我知道我不认识 Transfer Learning: 迁移学习 eg:学到的特征可以用在与数据集不太一样的测试上 Meta Learing: 学习如何学习，让程序具备学习的能力 Life-long Learning :终身学习（QAQ） Regression 寻找best function 损失函数 ：可以粗略的理解为（1-精度） 梯度下降：为了使损失函数最低。沿着梯度下降的地方测试W，在非线性回归中只能找到局部解，找不到全局解，但在线性回归时可以局部解=全局解 Basic concept 简单的model可能会有更大的bias，较小的variance，复杂的model会有较小的bias,较大的variance（一致性） underfitting来自于bias较大，overfitting来自于variance较大 如何分辨underfitting与overfitting：​ 如果模型不能拟合train_data，则为underfitting，如果模型可以拟合train_data，但不能拟合test_data,则为overfitting 如何解决underfitting与overfitting：​ underfitting：redesign model; ​ overfitting：more data ; regularization 梯度下降tip 1、learning rate(即公式中的yita)的大小，太小速度太慢，太大可能一步走的太大把min跳过 2、每个不同的参数给不同的learn rate，比如 3、adagrad： 4、随机梯度下降 5、特征放缩 损失内容QAQ Why deep1、深度网络可以用更少的数据达到更好的网络效果 2、可以让更多的特征表现出来 CNN 解决两个问题1、是否在测试集中的结果不好​ 1、Function没选好，存在梯度消失的问题 ​ 2、线性整流单元（ReLU）：比较快、生物理由 2、是否在训练集中的效果不好LSTM(RNN的一种)训练时 forget_gate要保持一个较大的bias来确保经常开启 可以解决梯度消失的问题： memory与input是add的","categories":[],"tags":[]},{"title":"","slug":"中医命名实体识别的改进","date":"2023-01-12T16:00:18.848Z","updated":"2023-02-04T17:17:24.117Z","comments":true,"path":"2023/01/13/中医命名实体识别的改进/","link":"","permalink":"https://yuzi2233.github.io/2023/01/13/%E4%B8%AD%E5%8C%BB%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E7%9A%84%E6%94%B9%E8%BF%9B/","excerpt":"","text":"中医命名实体识别的改进1、词典树建立中医文本词典树，其中第一个字建立hash，之后全部用数组实现[65535+1]; 2、 字符数 词语总数 总词频 平均词长 5116 325 501 2.2","categories":[],"tags":[]},{"title":"","slug":"WWDC","date":"2022-06-06T17:20:43.378Z","updated":"2022-07-09T02:56:20.084Z","comments":true,"path":"2022/06/07/WWDC/","link":"","permalink":"https://yuzi2233.github.io/2022/06/07/WWDC/","excerpt":"","text":"一个可以模拟安卓手机的代理Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) &gt; AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 &gt; Chrome/37.0.0.0 Mobile Safari/537.36 &gt; MicroMessenger/6.0.2.56_r958800.520 NetType/WIFI","categories":[],"tags":[]},{"title":"","slug":"3Blue1Brown","date":"2022-05-25T07:02:46.308Z","updated":"2022-05-25T09:12:42.429Z","comments":true,"path":"2022/05/25/3Blue1Brown/","link":"","permalink":"https://yuzi2233.github.io/2022/05/25/3Blue1Brown/","excerpt":"","text":"pa3Blue1Brown1、hamming code​ 汉明码是一种以奇偶校验为基础的一种纠错方法，相比于用二维奇偶校验的方法，它使用了更少的bit位，且可以检测多位错误（多位时无法修正） ​ 如下图为（15，11）汉明码，其中15指从0-15的16bit的数，11指包含了11个有效信息位（其中0位不算，详情见下）。可以按照信息论来计算，如果需要表达11位的数据具体的状态，需要log（2，11）=4位校验位，即最小用四位校验位才可以检测出来，小于4位就是违反信息论了。 ​ 汉明码存在位是(2^n),如1，2，4，8，这些数拥有一个特点其二进制只有一个1，如：0001，0010，0100，1000； ​ 根据汉明码我们可以对矩阵进行区分 ​ 第1位检测第二列、第四列：第2位检测第三列、第四列..0如下图所示； ​ 每一位汉明码都表示在该分组中的奇偶校验位; ​ 由于一共有16位的数据，用4位汉明码刚好检验16个错误状态，所以无法表示第17种状态：全部正确，所以我们忽略第0位，如果监测为第0位错误就认为正确。第0位还被扩展汉明码用作整体奇偶校验，可以检测两位错误（无法纠错），如图： 那么此时汉明码位置的特点就体现了出来，汉明码可以在特定的位置将矩阵分块 ​ 当然，我们可以通过这四个问题来找到出错的位置，但实际上，有更好的理解方式 ​ 通过示例观察错误的位置：7：0111，可以发现它每一位1正好对应上述的问题 通过以下四个问题，以二进制的形式回答了发生错误的位置， 如最后算出来的位置为0011：代表前两组没错，后两组有错，那么能影响后两组的只有3这个位置了 ​ 取很多数进行异或，实际上就是取他们的奇偶校验位。 当发送方发送正确的信息后，所有1位位置的异或为0，此时没有发生错误 那么可以想到，如果接收方接收到数据后，在错1位的情况下，所有1位置的异或即为这个位置（0000+/- 这个位置=这个位置） 代码如下： 12345678910import numpy as npfrom functools import reducebits = np.random.randint(0,2,16) #need to send#为每一位加上索引#enumerate(bits)#建立列表#[i for i, bit in enumerate(bits) if bit ] 可以把bit 为1的序号取出print(bits)print([i for i, bit in enumerate(bits) if bit])print(reduce(lambda x,y:x^y,[i for i, bit in enumerate(bits) if bit ]))","categories":[],"tags":[]},{"title":"","slug":"密码学","date":"2022-05-04T12:26:27.834Z","updated":"2022-05-04T12:26:27.834Z","comments":true,"path":"2022/05/04/密码学/","link":"","permalink":"https://yuzi2233.github.io/2022/05/04/%E5%AF%86%E7%A0%81%E5%AD%A6/","excerpt":"","text":"密码学定义如下三元组{K,M,C}; K为key 密钥、M为数据、C为加密过后的数据 1、流密码1、当K.len == M.len，则它是安全的 ​ 安全的定义：不可预测、不可通过部分密文还原出来。 ​ 可忽略不可忽略：简单理解位工程上的： 2、采用随机种子，随机生成K，此K.len远小于M.len，此时是肯定不安全的 ​ 例如奇偶校验，此时如果给定了密文的前M-1位，则可以判断第M位，这是不可忽略因素。 ​","categories":[],"tags":[]},{"title":"","slug":"C++ Prime 阅读笔记","date":"2022-03-23T10:45:21.937Z","updated":"2022-04-06T08:37:39.993Z","comments":true,"path":"2022/03/23/C++ Prime 阅读笔记/","link":"","permalink":"https://yuzi2233.github.io/2022/03/23/C++%20Prime%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"C++ Prime 阅读笔记第二章 变量和基本类型1、引用和指针的区别：引用并非一个对象，一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的哪个对象；指针和它存放的地址之间就没有这种限制了，和其他任何变量（除了引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。 123456789101112#include &lt;iostream&gt;int main() &#123; int i=1; int *p=&amp;i; printf(&quot;*p=%d\\n&quot;,*p); printf(&quot;p=%d\\n&quot;,p); std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 123*p=1p=6422036Hello, World! 2、常量的引用： 将引用绑定在const 对象上。与普通引用不同的是，对常量的引用不能呗用作修改它所绑定的对象。 常量指针：指向的地址不能变 顶层指针：指针本身是一个常量 底层指针：指针所指的对象是一个常量（所指的内容可以变可变） 1234567891011121314#include &lt;iostream&gt;int main() &#123; int i=1; // int *const p1 =&amp;i; //顶层 int 在前 const int ci =42; const int j =2; const int *p2 =&amp;ci; //底层 const int *p为指向的值是const，自己可变 p2=&amp;j; //可变，但不能通过p2改变ci的值 const int *const p3 =p2; const int &amp;r=ci; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; return 0;&#125; 3、指向二维数组的指针 12int array1[2][2]=&#123;1,2,3,4&#125;;int (*point)[2] =array1; 第三章、字符串、向量和数组1、String : s.size() 返回的是无符号数，如果和负数相比较，让负数变成无符号数，肯定会返回true 2、string 字符相加：+号两边必须有一个是string类型 3、字符串处理： 123456789int main()&#123; string s(&quot;Hello,World!&quot;); for (auto &amp;c :s) // &amp;别名，可以直接更改 &#123; c= toupper(c); &#125; cout &lt;&lt;s &lt;&lt;endl;&#125; 4、 迭代器：iterator \\ const_iterator ​ it -&gt;mem 与 (*it).mem 的含义是一样的 ​ 但凡使用了迭代器的循环体，都不要该改变容器的值 5、数组内置的索引值是有符号数，而vector和string是无符号数。 6、vector的数组 12vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));//把数组之间的元素放入voctor; 7、多维数组循环 1int array1[2][2]=&#123;1,2,3,4&#125;; 123for(const auto &amp;raw:array1) //要引用 for(auto a:raw) printf(&quot;%d&quot;,a); 12345for(auto p=begin(array1);p!=end(array1);++p)&#123; for (auto q= begin(*p);q!=end(*p);q++) cout&lt;&lt;*q&lt;&lt;&quot; &quot;;&#125; 第四章、表达式1、左值右值： 左值可以理解为在内存中的，可以赋值、可以经常赋值； 右值是在寄存器中的值 2、递增、递减运算符： ​ （1) 123int i =0,j;j=++i; // j = 1 ,i = 1 ;前置版本得到递增之后的值j=i++; // j= 1 , i=2 ;后置版本得到递增之前的值 ​ (2) 建议养成使用前置版本的习惯，这样不仅不需要担心性能问题，而且更重要的是写出的代码会更符合变成初衷 ​ （3） 第六章、函数参数1、传入数组大小： 12int j[]=&#123;0,1&#125;;test(j,end(j)-begin(j));","categories":[],"tags":[]},{"title":"","slug":"优质博客","date":"2022-03-20T12:30:53.076Z","updated":"2022-03-20T12:30:53.077Z","comments":true,"path":"2022/03/20/优质博客/","link":"","permalink":"https://yuzi2233.github.io/2022/03/20/%E4%BC%98%E8%B4%A8%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"优质博客Makefile书写规则 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)","categories":[],"tags":[]},{"title":"","slug":"毕设中遇到的一些问题","date":"2022-03-14T12:06:28.236Z","updated":"2022-04-19T06:31:28.760Z","comments":true,"path":"2022/03/14/毕设中遇到的一些问题/","link":"","permalink":"https://yuzi2233.github.io/2022/03/14/%E6%AF%95%E8%AE%BE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"毕设中遇到的一些问题1、在树莓派联网的过程中，会遇到连不上网的情况；首先要把wifi的共享打开=-= 2、看手机热点的ip：ip neigh 3、连网线的情况下，windows：ipconfig可以看到网段（192.168开头） ​ 如果是169.254开头就是没网，可以再去排查原因 4、下载复杂文件不能从windows传，会发生一些奇怪的错误，比如缩进等问题..要从git 上直接clone 5、直接看官方文档会方便很多 6、clion所有头文件找不到： 1include_directories(SYSTEM &quot;/foo/bar&quot;) 7、CmakeList.txt如下： 1234567891011121314cmake_minimum_required(VERSION 3.18.4)project(Dual_Gateway)set(CMAKE_CXX_STANDARD 14)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/inc $&#123;PROJECT_SOURCE_DIR&#125;/include)AUX_SOURCE_DIRECTORY(src DIR_SRCS)SET(SX1268 $&#123;DIR_SRCS&#125; main.cpp )add_executable(Dual_Gateway $&#123;SX1268&#125;)target_link_libraries(Dual_Gateway; wiringPi)add_executable(test test.cpp) 会找不到base64.c文件，原以为是cmake的问题，结果是C文件的问题，要变为C++的文件： cpp_base64.h: 123extern &quot;C&quot; &#123;#include &quot;base64.h&quot;&#125; SX1268接收信号的测试&lt;！！！！！要严格按照说明书的规范收发数据！！！！！！！&gt; 1、在TX模式下，先向TX写入数据，之后用SetTx()，设置Tx模式，他就会自动发；若不设置超时则持续处于TX状态下，否则发完以后就会变为StandBy模式。 2、在Rx模式下，发送的命令格式为： NOP也必须严格发送！","categories":[],"tags":[]},{"title":"","slug":"树莓派系统设置相关问题","date":"2022-03-13T06:04:23.716Z","updated":"2022-03-20T12:35:13.578Z","comments":true,"path":"2022/03/13/树莓派系统设置相关问题/","link":"","permalink":"https://yuzi2233.github.io/2022/03/13/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"树莓派系统设置相关问题1、网络配置使用网线直连PC，要把无线网的共享打开，如果出现169.254网段，就是还没有连网 然后 arp -a查看网段 找到192.168.137.1网段 使用192.168.137.59，这就是树莓派的IP地址 2、使用设置1、测试 GPIO 1gpio readall 错误，因为找不到源的问题 查了很久发现是作者不更新了 http://wiringpi.com/ 发布了一个最终版本，但不能用 apt-get 下载了 找到了如下下载方式 123cd /tmpwget https://project-downloads.drogon.net/wiringpi-latest.debsudo dpkg -i wiringpi-latest.deb 2、测试串口 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;wiringSerial.h&gt; int main(void)&#123; int hs1; int snum = 0; wiringPiSetup(); // 使用wiring编码去初始化GPIO序号 hs1 = serialOpen(&quot;/dev/ttyS0&quot;, 115200); // 打开 /dev/ttyS0 串口设备，波特率115200 printf(&quot;ttyS0 uart test1:\\n&quot;); // 终端打印 serialPrintf(hs1, &quot;Hello World!\\r\\n&quot;); // 串口打印 serialPrintf(hs1, &quot;Enter 10 letters:\\r\\n&quot;); /* 串口缓存区读取10个字节，并完整输出接收到的数据 */ do&#123; snum = serialDataAvail(hs1); // 获取串口接收缓存区的可用字节数 &#125;while(snum &lt; 10); while(snum--) &#123; serialPutchar(hs1,serialGetchar(hs1)); // 通过串口发送字节 &#125; serialPrintf(hs1, &quot;\\r\\nserial close\\r\\n\\r\\n&quot;); // 串口打印 serialClose(hs1); // 关闭串口 return 0;&#125; 编译报错，undefined reference to `wiringPiSetup’ ，要链接 wiringPi 1gcc test.c -o test -l wiringPi 编译成功","categories":[],"tags":[]},{"title":"","slug":"定时程序","date":"2022-03-12T14:30:36.199Z","updated":"2022-03-16T11:14:07.493Z","comments":true,"path":"2022/03/12/定时程序/","link":"","permalink":"https://yuzi2233.github.io/2022/03/12/%E5%AE%9A%E6%97%B6%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"抢票程序知识小点12crontab -lcrontab -e 5、 /etc/init.d/cron status 查看cron状态 6、sudo service cron restart cron/crontab日志在哪里？ - Ubuntu问答 (ubuntuqa.com) SSL routines:ssl_choose_client_version:unsupported protocol - 小良哥 - 博客园 (cnblogs.com)","categories":[],"tags":[]},{"title":"","slug":"全局变量的一些问题","date":"2022-03-04T04:09:32.067Z","updated":"2022-03-09T01:39:46.679Z","comments":true,"path":"2022/03/04/全局变量的一些问题/","link":"","permalink":"https://yuzi2233.github.io/2022/03/04/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"链接的一些问题1、基础知识程序变为可执行文件的过程 预处理：删除注释、#ifdef #endif 结果：.c、 .i 编译：转化为汇编程序 1gcc -S hello.i -o hello.s 汇编：转化为机器指令 1gcc -c hello.s -o hello.o 链接：将多个可重定位目标文件(.o)转化为可执行文件 1gcc -static -o test test.o test2.o (static 为静态链接) 链接的过程1、符号解析 2、重定位 ​ 1、同节合并 ​ 2、确定地址 ​ 3、修改引用 符号定义符号定义分为强定义与弱定义 强定义有：函数（int main(){~~~~}; void fun(){~}）,初始化的全局变量. 弱定义有：函数声明，未初始化的全局变量等 在函数中使用的局部变量不属于链接器管，存储在栈中。 有趣的例子程序有如下两个程序 test1.c 1234567891011#include&lt;stdio.h&gt;int d=100;int x=200;void p1(void);int main()&#123; p1(); printf(&quot; d=%d,x=%d \\n&quot;,d,x); return 0;&#125; test2.c 12345double d;void p1()&#123; d=1.0;&#125; 进过如下编译： 1gcc -o test test1.c test2.c 得到结果： 1d=0,x=1072693248 这个结果很奇怪，没有在任何地方定义d=0 结果分析两个程序都有全局变量d，但是类型不同。 test1里进行了初始化，所以这是一个强符号定义；test2里没有初始化，这一个弱符号定义。在链接的时候，弱符号以强符号为准。只允许有一个强符号，否则链接会报错。 但是程序在编译的时候使独自进行的 test2中的 d=1.0 会变成一个有关于double的赋值语句，目的是把1.0（IEEE754表示法）放入d的地址。但是编译时候并不确认这个地址。 链接的时候d以强定义为准，但是执行的赋值语句没有变，还是把1.0放入d的地址。 结果就导致一个64位的1.0放入了d,x的地址。 1.0的IEEE754表示法： 3FF0 0000 0000 0000 分为两个int即为：1072693248 0 ​ （小端方式） 使用全局变量的规则1、尽量使用本地变量static,模块内引用不会太出错 2、全局变量要赋值，使其进行为强定义，在链接时即可检测出错 3、外部全局变量使用extern，以示其引用的定义在其他模块 Tips1、静态链接要按照调用顺序去调用","categories":[],"tags":[]},{"title":"","slug":"Java1.8 HashMap源码研究","date":"2022-02-27T12:42:55.603Z","updated":"2022-03-02T07:13:25.672Z","comments":true,"path":"2022/02/27/Java1.8 HashMap源码研究/","link":"","permalink":"https://yuzi2233.github.io/2022/02/27/Java1.8%20HashMap%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/","excerpt":"","text":"Java1.8 HashMap源码研究 初次学习 参考文章 HashMap 主要静态变量1234static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 最小的Entry数量static final float DEFAULT_LOAD_FACTOR = 0.75f; //0.75的负载因子static final int TREEIFY_THRESHOLD = 8; //节点边成红黑树存储的门限static final int UNTREEIFY_THRESHOLD = 6; //变回链表的门限 主体结构：数组+链表+红黑树Map.Entry 数组 1static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 简单流程生成HashMap1234567public class TestHashMap &#123; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); TestHashMap() &#123; map.put(2,3); &#125;&#125; 我们指导hashmap是用数组的，那么没有给出数组下标如何使用数组 在源码中，根据给出的值随机生成一个hashcode 123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; 放入值12345678910111213141516171819final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); //调整大小，扩容*2（为什么不用ArrayList？ 答：HashMap中数组扩容刚好是2的次幂，在做取模运算的效率⾼。 ⽽ArrayList的扩容机制是1.5倍扩容 ） for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); //放入值 &#125; &#125;&#125; 生成以后需要将这个值 hash放入数组中，所以要匹配数组的大小，如下为源码中的做法 12if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 将hash值与表长（n-1）做&amp;运算，结果肯定在表长范围内。 可以回答以下问题： 为什么表长要为2的幂次方 这里我们也就得知为什么Table数组的长度要一直都为2的n次方，只有这样，减一进行相与时候，才能够达到最大的n-1值。 （1111） 而不是（1110），否则有几个位置一定会用不上，不符合hashmap均匀分布的想法。 put123456789101112131415161718192021222324252627282930313233343536373839404142434445final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //表空,扩容 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果这个hash值没有对应的，直接添加进去。 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果是相同的key但是不同的value，e=p else if (p instanceof TreeNode) //如果是树节点，则转化为插入树节点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //遍历 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果不存在当前的key，则插入 //如果大于TREEIFY_THRESHOLD - 1，则转化为树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //命中碰撞 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //如果两个值hash值也相等，key也相等，那么就是一个值，跳出if break; p = e; //链表下一个节点 &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; //新值代替旧值，所以一个key对应一个value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; resize()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //如果之前表的容量大于预设的最大值，那么就将表的容量边为int的最大数，几乎不会出现这种情况 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //扩容二倍 （ &lt;&lt; ） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 新的门限值 &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //相同的建立索引的方式 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //可以理解为遍历节点并插入，对头尾的指针做一个重新处理 do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; get()123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node //相匹配则返回 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; //循环 &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 相关问题 第三问为什么不一开始就使用红黑树，不是效率很高吗? 因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。当元素⼩于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素⼤于8个的时候，此时需要红⿊树来加快查 询速度，但是新增节点的效率变慢了。因此，如果⼀开始就⽤红⿊树结构，元素太少，新增效率⼜⽐较慢，⽆疑这是浪费性能的。第四问什么时候退化为链表为6的时候退转为链表。中间有个差值7可以防⽌链表和树之间频繁的转换。假设⼀下，如果设计成链表个数超过8则链表转 换成树结构，链表个数⼩于8则树结构转换成链表，如果⼀个HashMap不停的插⼊、删除元素，链表个数在8左右徘徊，就会 频繁的发⽣树转链表、链表转树，效率会很低。 四问HashMap的并发问题HashMap在并发环境下会有什么问题 一般是如何解决的 问题的出现(1)多线程扩容，引起的死循环问题(2)多线程put的时候可能导致元素丢失(3)put⾮null元素后get出来的却是null 不安全性的解决方案在之前使用hashtable。 在每一个函数前面都加上了synchronized 但是 效率太低 我们现在不常用了。 使用 ConcurrentHashmap函数，对于这个函数而言 我们可以每几个元素共用一把锁。用于提高效率。 五问你一般用什么作为HashMap的key值key可以是null吗，value可以是null吗 一般用什么作为key值 用可变类当Hashmap1的Key会有什么问题 让你实现一个自定义的class作为HashMap的Key该如何实现 key可以是null吗，value可以是null吗当然都是可以的，但是对于 key来说只能运行出现一个key值为null，但是可以出现多个value值为null 一般用什么作为key值⼀般⽤Integer、String这种不可变类当HashMap当key，⽽且String最为常⽤。(1)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。 这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。 这就是HashMap中的键往往都使⽤字符串。(2)因为获取对象的时候要⽤到equals()和hashCode()⽅法，那么键对象正确的重写这两个⽅法是⾮常重要的,这些类已 经很规范的覆写了hashCode()以及equals()⽅法。","categories":[],"tags":[]},{"title":"","slug":"CacheLab","date":"2022-02-23T14:10:28.433Z","updated":"2022-03-02T06:18:44.670Z","comments":true,"path":"2022/02/23/CacheLab/","link":"","permalink":"https://yuzi2233.github.io/2022/02/23/CacheLab/","excerpt":"","text":"cCacheLab前期准备 评分标准 相关ppt 安装valgrind内存泄露检测工具。1sudo apt install valgrind 相关参数1、 输入模式1234I 0400d7d4,8M 0421c7f0,4L 04f6b868,8S 7ff0005c8,8 The operation field denotes the type of memory access: “I” denotes an instruction load, “L” a data load, “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit hexadecimal memory address. The size field specifies the number of bytes accessed by the operation. 1234567Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;• -h: Optional help flag that prints usage info• -v: Optional verbose flag that displays trace info• -s &lt;s&gt;: Number of set index bits (S = 2^s is the number of sets)• -E &lt;E&gt;: Associativity (number of lines per set)• -b &lt;b&gt;: Number of block bits (B = 2^b is the block size)• -t &lt;tracefile&gt;: Name of the valgrind trace to replay 分析： ​ I 、M 、L 、S 为操作模式，I 为取指令，在本次lab里可以忽略；M 为修改，先取后存；L 为 load ；S 为store ​ 地址为最重要的参数，需要根据输入的 S E B 来确定，采取组相联的模式 ​ 地址分解函数如下： 1234567891011121314151617181920void Split(unsigned int *address_c,unsigned long address)&#123; int mask1=1,mask2=1; for(int i=0;i&lt;s-1;i++) &#123; mask1=mask1&lt;&lt;1; mask1=mask1|0x1; &#125; for(int i=0;i&lt;s+b-1;i++) &#123; mask2=mask2&lt;&lt;1; mask2=mask2|0x1; &#125; address_c[0]=0; //偏移量 address_c[1]=(address&gt;&gt;b)&amp;(mask1); //组号 address_c[2]=((address&gt;&gt;(b+s))); //标志位 return;&#125; 调试方法 1、标准测试 1./test-csim 2、标准cache测试 1./csim-ref -v -s 2 -E 2 -b 3 -t traces/trans.trace 3、自行测试 1./csim -v -s 2 -E 2 -b 3 -t traces/trans.trace 代码与注释Lab A123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include &quot;cachelab.h&quot;#include &quot;stdio.h&quot;#include &quot;getopt.h&quot;#include &lt;unistd.h&gt;#include &quot;string.h&quot;#include &quot;stdlib.h&quot;#include &quot;math.h&quot;const char *usage =&quot;Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;\\n&quot;;int v,h,s,E,b,t,S;unsigned int mask1=1,mask2=1;int hits=0,misss=0,evictions=0;char file[1000];//cache 采用二维动态数组建立struct Cache &#123; int vaild; //有效位 （未使用） int tag; //标志位 int LRU_flag; //LRU 标志位&#125;cache_block,*cache_set,**cache; //命中後，hits++， 更新LRU_flagvoid HIt(struct Cache *cache_set,int hit_num)&#123; hits++; if(v==1) &#123; printf(&quot; hit&quot;); &#125; for(int i=0;i&lt;E;i++) &#123; cache_set[i].LRU_flag++; //采用位数法：命中或使用过的清0，未使用过的+1 &#125; cache_set[hit_num].LRU_flag=0; return;&#125;//如果有空格，直接填入//沒有則置換void Eviction(struct Cache *set,int tag) //置换&#123; evictions++; if(v==1) &#123; printf(&quot; eviction&quot;); &#125; int max=0,index=0; for(int i=0;i&lt;E;i++) &#123; if(set[i].LRU_flag&gt;max) //置换最大的数 &#123; max=set[i].LRU_flag; index=i; &#125; set[i].LRU_flag++; //最开始将这句话遗忘了，置换以后也要将其他的+1； &#125; set[index].LRU_flag=0; set[index].tag=tag; return;&#125;void Miss(struct Cache *set,int tag)&#123; misss++; if(v==1) &#123; printf(&quot; miss&quot;); &#125; for(int i=0;i&lt;E;i++) &#123; if(set[i].vaild==0) //如果还有空闲块 &#123; set[i].vaild=1; set[i].tag=tag; set[i].LRU_flag=0; ///未完成 return; &#125; &#125; Eviction(set,tag); return;&#125;//寻找cache里面是否有对应的块void Search(unsigned long address,unsigned int *address_c)&#123; int set,flag; set=address_c[1]; flag=address_c[2]; for(int i=0;i&lt;E;i++) &#123; if(cache[set][i].tag==flag) &#123; HIt(cache[set],i); return; &#125; &#125; Miss(cache[set],address_c[2]); return;&#125;//分解地址函数void Split(unsigned int *address_c,unsigned long address)&#123; address_c[0]=0; address_c[1]=(address&gt;&gt;b)&amp;(mask1); address_c[2]=((address&gt;&gt;(b+s))); return;&#125;void init_Cache(int s, int E,int b)&#123; cache=malloc(sizeof(cache_set)*S); for(int i =0 ; i &lt; S ; i++) &#123; cache[i]=malloc(sizeof (cache_block)*E); for(int j=0;j&lt;E;j++) &#123; cache[i][j].tag=-1; cache[i][j].LRU_flag=0; cache[i][j].vaild=0; &#125; &#125; return;&#125;//读取文件void trace_test()&#123; FILE *pFile; pFile = fopen(file,&quot;r&quot;); if(pFile==NULL) exit(-1); char identifier; unsigned long address; int size; unsigned int address_c[3]; while(fscanf(pFile,&quot; %c %lx,%d&quot;,&amp;identifier,&amp;address,&amp;size)&gt;0) //在读文件的时候，fscanf要判断条件要&gt;0,否则没有结束 &#123; //TODO: switch (identifier) &#123; case &#x27;I&#x27;: break; case &#x27;L&#x27;: if(v==1) &#123; printf(&quot;%c %lx %d,&quot;,identifier,address,size); &#125; Split(address_c,address); Search(address,address_c); if(v==1) printf(&quot;\\n&quot;); break; case &#x27;S&#x27;: if(v==1) &#123; printf(&quot;%c %lx %d,&quot;,identifier,address,size); &#125; Split(address_c,address); Search(address,address_c); if(v==1) printf(&quot;\\n&quot;); break; case &#x27;M&#x27;: if(v==1) &#123; printf(&quot;%c %lx %d,&quot;,identifier,address,size); &#125; Split(address_c,address); Search(address,address_c); Search(address,address_c); if(v==1) printf(&quot;\\n&quot;); break; &#125; &#125; fclose(pFile);&#125;int main(int argc ,char** argv)&#123; int opt; while(-1!=(opt = getopt(argc, argv,&quot;vhs:E:b:t:&quot;))) //分解操作符 &#123; switch(opt) &#123; case &#x27;h&#x27;: puts(usage); return 0; case&#x27;v&#x27;: v = 1; break; case &#x27;s&#x27;: s = atoi(optarg); break; case &#x27;E&#x27;: E = atoi(optarg); break; case &#x27;b&#x27;: b=atoi(optarg); break; case &#x27;t&#x27;: strcpy(file, optarg); break; default: printf(&quot;wrong argument\\n&quot;); break; &#125; &#125; if(s&lt;=0 || E&lt;=0 || b&lt;=0 || file==NULL) // 如果选项参数不合格就退出 return -1; S=1&lt;&lt;s; //S=2^s for(int i=0;i&lt;s-1;i++) &#123; mask1=mask1&lt;&lt;1; mask1=mask1|0x1; &#125; for(int i=0;i&lt;s+b-1;i++) &#123; mask2=mask2&lt;&lt;1; mask2=mask2|0x1; &#125; init_Cache(s,E,b); //初始化cache内存空间 trace_test(); for(int i=0 ;i&lt;S;i++) //释放空间 free(cache[i]); free(cache); printSummary(hits, misss, evictions); return 0;&#125; lab A结果 Lab B1、分析test_trans他会根据输入的矩阵规模生成一段如LabA中的测试文档 如下（- M 2 -N 2） 1234567891011121314S 0068212c,1L 00682160,8L 00682124,4L 00682120,4L 00602120,4S 00642120,4L 00602124,4S 00642128,4L 00602128,4S 00642124,4L 0060212c,4S 0064212c,4S 0068212d,1 转化为二进制比较好观察 12345678910111213141516171819201101000001000 01001 01100 miss1101000001000 01011 00000 miss1101000001000 01001 00100 hit1101000001000 01001 00000 hit1100000001000 01001 00000 miss evi1100100001000 01001 00000 1100000001000 01001 001001100100001000 01001 010001100000001000 01001 010001100100001000 01001 001001100000001000 01001 011001101000001000 01001 01101 一个cache块可以存储8个int（32/4） 那么连续访问4个相同的就可以使命中率高一些？ 2、测试：1234567891011121314char trans_desc_1[] = &quot;step is 4 to transpose&quot;;void trans1_decs( int M, int N, int A[N][M], int B[M][N])&#123; int temp1=0,temp2=0,temp3=0,temp4=0; temp1=A[0][0]; temp2=A[0][1]; temp3=A[1][0]; temp4=A[1][1]; B[0][0]=temp1; B[0][1]=temp3; B[1][0]=temp2; B[1][1]=temp4;&#125; 猜测正确 继续思考，采取先取一定数量的A，在放入一定数量的B中。 由于有变量个数的限制，所以对于32*32的矩阵来说，可以将其进行分块，分块以后再每个小矩阵里进行操作 一次的取数最好为4的倍数，一人用16个块是最理想的，先试着分为16个 8*8 的矩阵。 123456789101112131415161718192021char transpose_submit_desc1[] = &quot;Transpose submission 1&quot;;void transpose_submit1(int M, int N, int A[N][M], int B[M][N]) &#123; int i,j,k,l; if(M==32&amp;&amp;N==32) &#123; for(i=0;i&lt;4;i++) &#123; for(j=0;j&lt;4;j++) &#123; for(k=8*i;k&lt;8*i+8;k++) &#123; for(l=8*j;l&lt;8*j+8;l++) &#123; B[l][k]=A[k][l]; &#125; &#125; &#125; &#125; &#125;&#125; 得到如下结果： 1func 1 (Transpose submission 1): hits:1710, misses:343, evictions:311 misses=343&gt;300 ，这并不是一个满分结果，寻找有没有改进方法。 3、改进可以对对角线的元素动刀。 我们发现上述代码A每次是按照cache取的，而B每次都需要重新装填。 如果最后处理在遍历完A的一个小矩阵后，最后处理对角线元素，则B的对角线元素也会和后面的3个元素一起装填，在下一时候会多命中一个。大概最后会减少60个左右miss 1234567891011121314151617181920212223242526272829303132333435char transpose_submit_desc1[] = &quot;Transpose submission 1&quot;;void transpose_submit1(int M, int N, int A[N][M], int B[M][N]) &#123; int i,j,k,l; int same=0,index; if(M==32&amp;&amp;N==32) &#123; for(i=0;i&lt;4;i++) &#123; for(j=0;j&lt;4;j++) &#123; for(k=8*i;k&lt;8*i+8;k++) &#123; for(l=8*j;l&lt;8*j+8;l++) &#123; if(l!=k) &#123; B[l][k]=A[k][l]; &#125; else &#123; same=A[l][l]; index=l; &#125; &#125; if(index==k) &#123; B[index][index]=same; &#125; &#125; &#125; &#125; &#125;&#125; -M 64 -N 64直接测试32*32的方法 123456789101112131415void trans_2(int M, int N, int A[N][M], int B[M][N])&#123; for(int i = 0; i &lt; N; i += 8) &#123; for(int j = 0; j &lt; M; j += 8) &#123; for(int ii = i; ii &lt; i + 8; ii++) &#123; for(int jj = j; jj &lt; j + 8; jj++) B[jj][ii] = A[ii][jj]; &#125; &#125; &#125;&#125; misses:4663，0分。 看一下内存访问的次序，可以发现 与 会发生冲突。 在同一个8*8的块内就会发生冲突。 所以考虑变成4*4的块 misses:1914 ，可以发现大幅度降低。 但是还是达不到满分的要求。 想了很久还是没有方法，所以参考一下网络大神们的方法.. 猫大神 1 -M 61 -N 67不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache，但是由于要求比较松，我们可以尝试一些分块的大小，直接进行转置操作。尝试到16左右 ，可以小于2000次miss。 1 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144void transpose_submit(int M, int N, int A[N][M], int B[M][N])&#123; //you are allowed to define at most 12 local variables of type int //per transpose function. int sets_num = M/8; int sets_remainder = M%8; int i, j, k, l; int f, g, h; int tmp, same; //int same; /*blocking: divide the matrix into sub-matrices. size of sub-matrix depends on cache block size, cache size, input matrix size.*//**32 X 32 ***************************************************************/ if (M == 32 &amp;&amp; N == 32)&#123; //divide the matrix into 8*8 block and be careful for the i == j eviction for(l=0; l &lt; 4; l++)&#123; for(k=0; k &lt; 4; k++)&#123; /*block size 8 * 8 */ for (i = l*8; i &lt; l*8+8; i++)&#123; for (j = k*8; j &lt; k*8+8; j++) &#123; if(i!=j) &#123; B[j][i]=A[i][j]; &#125; //special handling for same block else&#123; //B[j][i] = A[i][j] for the same i, j will cause cache miss. //=&gt; do the calculation at the end tmp=A[j][j]; same = j; &#125; &#125; if(k==l)&#123; B[same][same] = tmp; &#125; /**************************/ &#125; &#125; &#125; &#125;/**32 X 32 ***************************************************************//**64 X 64 ***************************************************************/ else if (M==64 &amp;&amp; N == 64)&#123; /* divide the matrix into 8*8 blocks, do the calculation separately for upper half and lower half */ //variables don&#x27;t mean anything here. Just reusing because limited. for(i=0; i&lt;64; i+=8)&#123; for(j=0; j&lt;64; j+=8)&#123; for(k=0; k&lt;4; k++)&#123; l = A[i+k][j+0]; tmp = A[i+k][j+1]; same = A[i+k][j+2]; sets_remainder = A[i+k][j+3]; sets_num = A[i+k][j+4]; f = A[i+k][j+5]; g = A[i+k][j+6]; h = A[i+k][j+7]; B[j+0][i+k+0] = l; B[j+0][i+k+4] = f; B[j+1][i+k+0] = tmp; B[j+1][i+k+4] = g; B[j+2][i+k+0] = same; B[j+2][i+k+4] = h; B[j+3][i+k+0] = sets_remainder; B[j+3][i+k+4] = sets_num; &#125; l = A[i+4][j+4]; tmp = A[i+5][j+4]; same = A[i+6][j+4]; sets_remainder = A[i+7][j+4]; sets_num = A[i+4][j+3]; f = A[i+5][j+3]; g = A[i+6][j+3]; h = A[i+7][j+3]; B[j+4][i+0] = B[j+3][i+4]; B[j+4][i+4] = l; B[j+3][i+4] = sets_num; B[j+4][i+1] = B[j+3][i+5]; B[j+4][i+5] = tmp; B[j+3][i+5] = f; B[j+4][i+2] = B[j+3][i+6]; B[j+4][i+6] = same; B[j+3][i+6] = g; B[j+4][i+3] = B[j+3][i+7]; B[j+4][i+7] = sets_remainder; B[j+3][i+7] = h; for(k=0;k&lt;3;k++)&#123; l = A[i+4][j+5+k]; tmp = A[i+5][j+5+k]; same = A[i+6][j+5+k]; sets_remainder = A[i+7][j+5+k]; sets_num = A[i+4][j+k]; f = A[i+5][j+k]; g = A[i+6][j+k]; h = A[i+7][j+k]; B[j+5+k][i+0] = B[j+k][i+4]; B[j+5+k][i+4] = l; B[j+k][i+4] = sets_num; B[j+5+k][i+1] = B[j+k][i+5]; B[j+5+k][i+5] = tmp; B[j+k][i+5] = f; B[j+5+k][i+2] = B[j+k][i+6]; B[j+5+k][i+6] = same; B[j+k][i+6] = g; B[j+5+k][i+3] = B[j+k][i+7]; B[j+5+k][i+7] = sets_remainder; B[j+k][i+7] = h; &#125; &#125; &#125; &#125;/**64 X 64 ***************************************************************//**61 X 67 ***************************************************************/ else&#123; for (i = 0; i &lt; N; i+=8) &#123; for (j = 0; j &lt; M; j+= 8) &#123; for (k = j;(k&lt;j+8) &amp;&amp; (k&lt;M);++k) &#123; for (l = i; (l&lt;i+8)&amp;&amp;(l&lt;N); ++l) &#123; B[k][l] = A[l][k]; &#125; &#125; &#125; &#125; &#125;/**61 X 67 ***************************************************************/&#125;","categories":[],"tags":[]},{"title":"","slug":"Docker 从入门到入土","date":"2022-02-23T07:25:00.907Z","updated":"2022-02-23T07:25:00.909Z","comments":true,"path":"2022/02/23/Docker 从入门到入土/","link":"","permalink":"https://yuzi2233.github.io/2022/02/23/Docker%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","excerpt":"","text":"Docker 从入门到入土 –郭域 一、Docker是什么 Docker是什么 二、Docker三大组件1、Docker镜像Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。 2、Docker容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 3、Docker仓库三、使用Docker1、 获取镜像之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： $ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub(docker.io`)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library`，也就是官方镜像。 1docker pull ubuntu:18.04 2、运行镜像123456789101112131415$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;18.04.1 LTS (Bionic Beaver)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 18.04.1 LTS&quot;VERSION_ID=&quot;18.04&quot;HOME_URL=&quot;https://www.ubuntu.com/&quot;SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;VERSION_CODENAME=bionicUBUNTU_CODENAME=bionic docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。","categories":[],"tags":[]},{"title":"","slug":"Lab3 Buffer lab","date":"2022-02-06T12:18:37.498Z","updated":"2022-02-06T12:18:37.498Z","comments":true,"path":"2022/02/06/Lab3 Buffer lab/","link":"","permalink":"https://yuzi2233.github.io/2022/02/06/Lab3%20Buffer%20lab/","excerpt":"","text":"Lab3 Buffer lab1、说明","categories":[],"tags":[]},{"title":"bomblab","slug":"bomblab","date":"2022-01-22T15:54:42.000Z","updated":"2022-02-02T16:29:42.695Z","comments":true,"path":"2022/01/22/bomblab/","link":"","permalink":"https://yuzi2233.github.io/2022/01/22/bomblab/","excerpt":"","text":"LAB2 BOMBGDB的使用查看函数的汇编码1234567891011disas phase_1 #显示代码info break #显示断点d 2 #删除第二个断点b phase_1 #插入断点 next #逐过程step #逐语句info registers #查看寄存器（gdb）enable breakpoints：启用断点（gdb）disable breakpoints：禁用断点 -x 的使用可以使用examine命令(简写是x)来查看内存地址中的值。x命令的语法如下所示： x/&lt;n/f/u&gt; n、f、u是可选的参数。 n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。 f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 表示一个内存地址。 注意：严格区分n和u的关系，n表示单元个数，u表示每个单元的大小。 n/f/u三个参数可以一起使用。例如： 命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按无符号十进制显示。 1x/s 可以显示一个地址的字符串 第一关输入指令 1disas phase_1 可以得到如下代码 1234567890x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp #压栈必备操作0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi #立即数0x0000000000400ee9 &lt;+9&gt;: callq 0x401338 &lt;strings_not_equal&gt; # 比较函数，这就要和我们输入的字符串进行比较了0x0000000000400eee &lt;+14&gt;: test %eax,%eax0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp0x0000000000400efb &lt;+27&gt;: retq 使用命令 1x/s 0x402400 即可得到字符串 “Border relations with Canada have never been better.” 第二关phase_2 12345678910111213141516171819202122232425400efc: 55 push %rbp400efd: 53 push %rbx400efe: 48 83 ec 28 sub $0x28,%rsp400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt;400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) #与1比较400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt;400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt;400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt;400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax #相当于*2的操作400f1c: 39 03 cmp %eax,(%rbx)400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt;400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt;400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt;400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt;400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt;400f3c: 48 83 c4 28 add $0x28,%rsp400f40: 5b pop %rbx400f41: 5d pop %rbp400f42: c3 retq read_six_numbers 1234567891011121314151617180x000000000040145c &lt;+0&gt;: sub $0x18,%rsp0x0000000000401460 &lt;+4&gt;: mov %rsi,%rdx0x0000000000401463 &lt;+7&gt;: lea 0x4(%rsi),%rcx0x0000000000401467 &lt;+11&gt;: lea 0x14(%rsi),%rax #都是输入数字的操作0x000000000040146b &lt;+15&gt;: mov %rax,0x8(%rsp)0x0000000000401470 &lt;+20&gt;: lea 0x10(%rsi),%rax0x0000000000401474 &lt;+24&gt;: mov %rax,(%rsp)0x0000000000401478 &lt;+28&gt;: lea 0xc(%rsi),%r90x000000000040147c &lt;+32&gt;: lea 0x8(%rsi),%r80x0000000000401480 &lt;+36&gt;: mov $0x4025c3,%esi0x0000000000401485 &lt;+41&gt;: mov $0x0,%eax0x000000000040148a &lt;+46&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x000000000040148f &lt;+51&gt;: cmp $0x5,%eax0x0000000000401492 &lt;+54&gt;: jg 0x401499 &lt;read_six_numbers+61&gt;0x0000000000401494 &lt;+56&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401499 &lt;+61&gt;: add $0x18,%rsp0x000000000040149d &lt;+65&gt;: retq 1 2 4 8 16 32 第三关1234567891011121314151617181920212223242526272829303132333435360x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx #输入第一个数的地址0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx #输入第二个数的地址0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax0x0000000000400f5b &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax #比较参数0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt; 0x0000000000400f65 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp) #第一个数要&lt;70x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax #把第一个参数传入eax（rax）0x0000000000400f75 &lt;+50&gt;: jmpq *0x402470(,%rax,8) #通过传入的参数跳转0x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;: mov $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;: mov $0x100,%eax0x0000000000400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;: mov $0x185,%eax0x0000000000400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;: mov $0xce,%eax0x0000000000400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;: mov $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;: mov $0x147,%eax0x0000000000400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;: mov $0x0,%eax0x0000000000400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;: mov $0x137,%eax0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax #eax与第二个参数比较，这里选择2，所以为7070x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;: add $0x18,%rsp0x0000000000400fcd &lt;+138&gt;: retq 1、可以通过如下命令查看输入 123(gdb)x/s 0x4025cf0x4025cf: &quot;%d %d&quot; 2、到了跳转命令后 1jmpq *0x402470(,%rax,8) 3、查看该命令跳转到哪，以输入2为例子 123(gdb) x *0x4024800x400f83 &lt;phase_3+64&gt;: 0x0002c3b8 4、跳转到+64的位置 10x0000000000400f83 &lt;+64&gt;: mov $0x2c3,%eax 5、跳转到+123的位置进行比较 2 707 成功通过 第四关phase_4 123456789101112131415161718192021220x000000000040100c &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx #a 0x0000000000401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx #b 0x000000000040101a &lt;+14&gt;: mov $0x4025cf,%esi #x/s : &quot;%d %d&quot; 0x000000000040101f &lt;+19&gt;: mov $0x0,%eax 0x0000000000401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax 0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt; 0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp) 0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt; #b&lt;=14 0x0000000000401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x000000000040103a &lt;+46&gt;: mov $0xe,%edx #edx=14 ，关键参数 0x000000000040103f &lt;+51&gt;: mov $0x0,%esi #esi=0 0x0000000000401044 &lt;+56&gt;: mov 0x8(%rsp),%edi #edi=b 0x0000000000401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt; 0x000000000040104d &lt;+65&gt;: test %eax,%eax #最终的目的是让eax=0，所以找一个数让eax=0即可 0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt; 0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp) # 参数a只在这里用了一次，所以确定为0 0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt; 0x0000000000401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x000000000040105d &lt;+81&gt;: add $0x18,%rsp fun4 （一个比较复杂的函数，但实际上是不用看的很详细的） 12345678910111213141516171819202122230x0000000000400fce &lt;+0&gt;: sub $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;: mov %edx,%eax #eax=14 #0x0000000000400fd4 &lt;+6&gt;: sub %esi,%eax #eax=14-0 eax-esi=6 2 00x0000000000400fd6 &lt;+8&gt;: mov %eax,%ecx #ecx=eax=14 eax=ecx=6 2 00x0000000000400fd8 &lt;+10&gt;: shr $0x1f,%ecx #eck #清00x0000000000400fdb &lt;+13&gt;: add %ecx,%eax #eax=14 6 2 00x0000000000400fdd &lt;+15&gt;: sar %eax #eax/2 7 3 1 0 #/2的操作0x0000000000400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx #ecx=7 rsi=0 11（3+8） 13(12+1)0x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx #(14 7) (14,11) 0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt; #jump #小于等于0x0000000000400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;: callq 0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;: add %eax,%eax0x0000000000400ff0 &lt;+34&gt;: jmp 0x401007 &lt;func4+57&gt; #exit 20x0000000000400ff2 &lt;+36&gt;: mov $0x0,%eax #eax=0 需要保留这个条件0x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx #(14 7) (14,11) (14 13)0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt; ##3exit 1 #大于等于0x0000000000400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi #esi=8 12 14 ##不能进入这个,否则肯定不能=00x0000000000400ffe &lt;+48&gt;: callq 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax #除非rax=00x0000000000401007 &lt;+57&gt;: add $0x8,%rsp0x000000000040100b &lt;+61&gt;: retq 可以发现，如果是临界值7，就可以直接跳出循环 7，0 第五关12345678910111213141516171819202122232425262728293031323334353637380x0000000000401062 &lt;+0&gt;: push %rbx0x0000000000401063 &lt;+1&gt;: sub $0x20,%rsp0x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx0x000000000040106a &lt;+8&gt;: mov %fs:0x28,%rax #栈溢出检测0x0000000000401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;: xor %eax,%eax #清00x000000000040107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax #输入长度为6的字符串--&gt;1120x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx #eax=0 ecx=97 (rbx)=A[1]0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx #0x0000000000401096 &lt;+52&gt;: and $0xf,%edx #保留四位 rdx=1 30x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx #取低字节 ，从这个地址取字0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;: movb $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi # &quot;flyers&quot; 需要比较的字符串0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;: mov $0x0,%eax0x00000000004010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;: mov 0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;: xor %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt;00x00000000004010e9 &lt;+135&gt;: callq 0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;: add $0x20,%rsp0x00000000004010f2 &lt;+144&gt;: pop %rbx0x00000000004010f3 &lt;+145&gt;: retq 前面是要将六个字符入栈 但并非输入的六个字符 可以发现是从如下地址取字 10x4024b0(%rdx),%edx #取低字节 输入如下指令得到 1x 0x4024b0 maduiersnfotvbyl 梳理代码逻辑可以发现是按照我们所输入字母的低4bit来定位的，如输入a=0x61,则定位 1 字符，恰巧也位a 所以如下 “flyers” = 9 f e 5 6 7 找几个字符后4bit与其相符： ionefg 第六关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586870x00000000004010f4 &lt;+0&gt;: push %r140x00000000004010f6 &lt;+2&gt;: push %r130x00000000004010f8 &lt;+4&gt;: push %r120x00000000004010fa &lt;+6&gt;: push %rbp0x00000000004010fb &lt;+7&gt;: push %rbx #压栈0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp0x0000000000401100 &lt;+12&gt;: mov %rsp,%r13 #栈底0x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi #栈底0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt; # ( 1,2,3,4,5,6 )0x000000000040110b &lt;+23&gt;: mov %rsp,%r14 #栈顶0x000000000040110e &lt;+26&gt;: mov $0x0,%r12 # r12=00x0000000000401114 &lt;+32&gt;: mov %r13,%rbp #栈底 #r12即为当前数0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax #第一个数0x000000000040111b &lt;+39&gt;: sub $0x1,%eax # (6)-10x000000000040111e &lt;+42&gt;: cmp $0x5,%eax # () 第一个数为0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; #&lt;=5 跳转 所以数应该为： 1 2 3 4 5 6之中，jbe为无符号数判断，所以不考虑00x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d #r12=10x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d #循环0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx #ebx=10x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax #rax=10x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax #eax=(rsp+4)0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp) #第二个数和第一个数的关系为不相等，————所有数与第一个数不相等0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx #循环0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;: add $0x4,%r13 #第二个数 #0x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt;0x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi # 0 0x0000000000401158 &lt;+100&gt;: mov %r14,%rax #rsp0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx #ecx=70x0000000000401160 &lt;+108&gt;: mov %ecx,%edx #edx=70x0000000000401162 &lt;+110&gt;: sub (%rax),%edx #7-a() 7-输入的参数0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) #放到原来的位置，7-n 倒过来，比如0x0000000000401166 &lt;+114&gt;: add $0x4,%rax #下一个0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax #到0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt;0x000000000040116f &lt;+123&gt;: mov $0x0,%esi #esi=00x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; #jmp0x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx #0x000000000040117a &lt;+134&gt;: add $0x1,%eax #eax=20x000000000040117d &lt;+137&gt;: cmp %ecx,%eax0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) #rsp+20开始放入 0x6032d0+f*x,如果是6的话直接放如0x632d00x000000000040118d &lt;+153&gt;: add $0x4,%rsi0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi #6次0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx #ecx=60x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx #每次取数要和1比0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;: mov $0x1,%eax #eax=10x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx #第一个节点的位置0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt;0x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx #rbx =第一个数的地址0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax #rax =rsp+280x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi #rsp+500x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx #0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx #rdx=第二个数的地址0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx) #建立链表，前8位为数字，后8为位下个的地址0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax 0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx)# ----链表尾0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp #0x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax 0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx) #0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt; #在下面的要比在上面的小才行！0x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp0x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;: add $0x50,%rsp0x00000000004011fb &lt;+263&gt;: pop %rbx0x00000000004011fc &lt;+264&gt;: pop %rbp0x00000000004011fd &lt;+265&gt;: pop %r120x00000000004011ff &lt;+267&gt;: pop %r130x0000000000401201 &lt;+269&gt;: pop %r140x0000000000401203 &lt;+271&gt;: retq 过程： 1、首先输入六个数字，然后判断一下是否输入为小于等于6的数（+45） 2、判断是不是有重复的。(+71) 3、将输入的数用 7 减，放回原来位置，比如输入 6 5 4 3 2 1 就变成了 1 2 3 4 5 6 （+100 ~+128） 4、注意到一个特殊的立即数，$0x6032d0（+143 +176），用 x 0x6032d0查看，可以发现node1，之后每次+16，可以发现一个node数组， 12345678910111213(gdb) x $rbx0x603320 &lt;node6&gt;: 443(gdb) x $rbx-160x603310 &lt;node5&gt;: 477(gdb) x $rbx-320x603300 &lt;node4&gt;: 691(gdb) x $rbx-480x6032f0 &lt;node3&gt;: 924(gdb) x $rbx-640x6032e0 &lt;node2&gt;: 168(gdb) x $rbx-800x6032d0 &lt;node1&gt;: 332 然后按照 （7-n）的顺序排列 从（rsp+0x20）开始，（+148） 比如目前顺序为6 5 4 3 2 1 则第一个数字6对应 332的位置=（rsp+0x20+6*8(一个数字占用的位置)） 相当于用输入的数字对node进行排序 5、建立链表 （+183~+222） 前面为数字，后面为下一个数字的地址（+204） 从rsp+20开始 6、通过链表比较大小 （+230~+257） 要求前面的要比后面的小 (+243) 7、自定义排序大小，然后用7减 答案为：4 3 2 1 6 5 结语​ 一阶段：大概用了一周的时间解完了，基本没遇到什么问题。但是实际上感觉基础知识并不扎实。明天过书吧，相信做完以后再过书，肯定会有不一样的收获.","categories":[],"tags":[]},{"title":"CSAPP LAB1","slug":"CSAPP-LAB1","date":"2022-01-14T04:46:08.000Z","updated":"2022-02-03T08:03:11.183Z","comments":true,"path":"2022/01/14/CSAPP-LAB1/","link":"","permalink":"https://yuzi2233.github.io/2022/01/14/CSAPP-LAB1/","excerpt":"","text":"CSAPPLAB1注：在Makefile中要把-m32改为-m64 1、bitAnd(int, int); 12345int bitAnd(int x, int y) &#123; unsigned z; z=~((~x)|(~y)); return z;&#125; 2、getByte(int x, int n)123 * int getByte(int x, int n) &#123; return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xFF &#125; 3、logicalShift(int x, int n)12345678int logicalShift(int x, int n) &#123; int z=0x80000000; if (n==0) return x; else return (x&gt;&gt;n)&amp;(~(z&gt;&gt;(n-1))); //之前直接写0x80000000,结果不对，会把他看成无符号数进行逻辑右移，换为int以后就是算数右移了&#125; &lt;上述使用了禁止的符号 ‘ - ‘，数0x800000000,所以找方法把他们替换掉&gt; 1234int logicalShift(int x, int n) &#123; int z=(0x1&lt;&lt;31); return (x&gt;&gt;n)&amp;(~(z&gt;&gt;(n)&lt;&lt;1));&#125; 4、bitCount(int x)（1）、初次尝试 12345678910int bitCount(int x) &#123; int count=0; unsigned z=x; //禁止unsigned while(z!=0) //禁止while &#123; count=count+(z&amp;0x1); z=z&gt;&gt;1; &#125; return count;&#125; (2) 5、fitsBits(int x, int n)1234567891011121314/* * fitsBits - return 1 if x can be represented as an * n-bit, two&#x27;s complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; int z=(0x1&lt;&lt;31)&gt;&gt;32; //制早0xffffffff,也就是-1；；；； -1=~0....想复杂了 return !((x&gt;&gt;(n+z))^(x&gt;&gt;31));//x右移n-1位，与符号位异或，再去！ &#125; 6、negate(int x);123int negate(int x) &#123; return ~x+1;&#125; 7、int isPositive(int x)1234567891011/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; return (!x^!(x&gt;&gt;31)); // x&gt;&gt;31位即可判断正负，但是要考虑0的情况。用^去判断，如果是0，！0=1，！0（符号位）=1 ，1^1=0&#125; 8、int divpwr2(int x, int n) 1234567891011121314151617181920212223/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round 3b b /toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 *//*正数直接移负数移动以后有的要+1如果可以完全被二整除则不用，如果不能完全被二整除则需要。可以想到判断移动后的，但是不方便所以想到对原数进行处理加一个偏移量(2^n-1)*/int divpwr2(int x, int n) &#123; int flag=(x&gt;&gt;31);//符号 int a =(0x1&lt;&lt;n)+(~0); // 2^n-1; return (x + (flag &amp; a) ) &gt;&gt; n ;&#125; 9、isLessOrEqual(int x, int y)123456789101112131415161718192021/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 *//*很容易想到判断y-x的符号位，但是当两个数异号就会产生溢出的情况。异号的话只用看x的符号就行所以把两种情况分开讨论。*/int isLessOrEqual(int x, int y) &#123; int sign1=x&gt;&gt;31&amp;0x1; //x符号位 int sign2=y&gt;&gt;31&amp;0x1; //y符号位 int z=y+(~x+1); //z=y-x return (( !((z&gt;&gt;31)&amp;0x1) &amp; ( !(sign1^sign2) ) ) ) | ( (sign1^sign2)&amp;sign1 ); // 判断z的符号 同号 | 异号 x的符号&#125; 10、ilog2(int x) （不会） （1、只能检测一位的方法......） 1234567891011121314151617181920212223242526272829303132333435363738/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 *s Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int seg1=x&gt;&gt;24&amp;0xff; int seg1_f=!!seg1; int seg2=x&gt;&gt;16&amp;0xff; int seg2_f=!!seg2; int seg3=x&gt;&gt;8&amp;0xff; int seg3_f=!!seg3; int seg4=x&amp;0xff; int seg4_f=!!seg4; int res=seg1^seg2^seg3^seg4; int res_s1=res&gt;&gt;4&amp;0xf; int res_s1_f=!!res_s1; int res_s2=res&amp;0xf; int res_s2_f=!!res_s2; int res2=res_s1^res_s2;//4 int res2_s1=res2&gt;&gt;2&amp;0x3; int res2_s1_f=!!res2_s1; int res2_s2=res2&amp;0x3; int res2_s2_f=!!res2_s2; int res3=res2_s1^res_s2;//2 int sta=res3-1;//first or second int count1=((2+sta)&amp;~(res2_s1_f-1))+((0+sta)&amp;~(res2_s2_f-1)); int count2=((4+count1)&amp;~(res_s1_f-1))+((0+count1)&amp;~(res_s2_f-1)); int count3=((24+count2)&amp;~(seg1_f-1))+((16+count2)&amp;~(seg2_f-1))+((8+count2)&amp;~(seg3_f-1))+((0+count2)&amp;~(seg4_f-1)); 11、float_i2f(int x) （int 转float）123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_i2f(int x) &#123; if(x == 0) return x; if(x == 0x80000000) //min单独考虑 return 0xcf000000; int sign=x&gt;&gt;31&amp;0x1; //符号位 int temp=x; // int E=0; //阶码 int tail=0; //尾数 if(x&lt;0) temp=~x+1; //如果是负数，就取反加一（不考虑符号位） int rel=temp; while(!!(temp&gt;&gt;1)) //求阶码 &#123; E++; temp=temp&gt;&gt;1; &#125; tail = ((rel &lt;&lt; (32 - E)) &gt;&gt; 9) &amp; 0x7fffff; //算尾数 int flag = (rel &lt;&lt; (32 - E)) &amp; 0x1ff;//要被移出去的部分 int jinwei = (flag &gt; 256) || ((flag == 256) &amp;&amp; (tail &amp; 1));//如果&gt;256,说明最后一位是1，一定要进位，=256就要看尾数 末尾 E = E + 127; tail = tail + jinwei; //进位 if(tail &gt;&gt; 23) //如果溢出，则E+1 &#123; tail = tail &amp;0x007FFFFF; E+=1; &#125; unsigned result = (sign &lt;&lt; 31) | (E &lt;&lt; 23) | (tail &amp; 0x7fffff); //拼接 0. return result;&#125; 12、float_twice(unsigned uf)123456789101112131415161718192021222324252627282930313233343536/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; if(((uf&lt;&lt;1)&amp;0xff000000)==0xff000000) //NAN return uf; if (uf==0) //0 return 0; if(uf == 0x80000000) //min return 0x80000000; unsigned E=uf&gt;&gt;23&amp;0xff; unsigned M=uf&amp;0x007FFFFF; unsigned result; unsigned New_E=E+1; if(E!=0) &#123; result=(uf&amp;0x807fffff)|(New_E&lt;&lt;23); //阶码+1 &#125; else if(M!=0) result=uf&amp;0xff800000|(M&lt;&lt;1); //E=0时候，只要尾数*2即可 return result;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-28T08:32:41.247Z","updated":"2021-12-28T08:32:41.247Z","comments":true,"path":"2021/12/28/hello-world/","link":"","permalink":"https://yuzi2233.github.io/2021/12/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}